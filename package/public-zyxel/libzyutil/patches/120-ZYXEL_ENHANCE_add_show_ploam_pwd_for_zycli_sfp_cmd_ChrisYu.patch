Index: libzyutil-1.0/zyutil_sfp.c
===================================================================
--- libzyutil-1.0.orig/zyutil_sfp.c	2020-04-08 18:13:16.003168234 +0800
+++ libzyutil-1.0/zyutil_sfp.c	2020-04-08 18:14:26.814971255 +0800
@@ -33,10 +33,10 @@
 #define DDMI1_VENDOR_SN_LENGTH		16
 #define DDMI1_DM_TYPE_OFFSET		92
 #define DDMI1_DM_TYPE_LENGTH		1	// Diagnostic monitoring type
-    #define INTERNAL_CALIBRATED_OFFEST	5
-    #define INTERNAL_CALIBRATED_MASK	(0x1 << INTERNAL_CALIBRATED_OFFEST)
-    #define EXTERNAL_CALIBRATED_OFFEST	4
-    #define EXTERNAL_CALIBRATED_MASK	(0x1 << EXTERNAL_CALIBRATED_OFFEST)
+#define INTERNAL_CALIBRATED_OFFEST	5
+#define INTERNAL_CALIBRATED_MASK	(0x1 << INTERNAL_CALIBRATED_OFFEST)
+#define EXTERNAL_CALIBRATED_OFFEST	4
+#define EXTERNAL_CALIBRATED_MASK	(0x1 << EXTERNAL_CALIBRATED_OFFEST)
 
 #define DDMI2_RX_POWER_CALIB_4_OFFSET   56
 #define DDMI2_RX_POWER_CALIB_4_LENGTH   4
@@ -68,8 +68,12 @@
 #define DDMI2_GPON_SN_OFFSET		    233
 #define DDMI2_GPON_SN_LENGTH		    8
 
-    #define DDMI_DATA_READY_BAR_OFFSET	0
-    #define DDMI_DATA_READY_BAR_MASK	(0x1 << DDMI_DATA_READY_BAR_OFFSET)	// low is ready.
+//Ploam Password
+#define DDMI2_GPON_PLOAM_PWD_OFFSET		215
+#define DDMI2_GPON_PLOAM_PWD_LENGTH		12
+
+#define DDMI_DATA_READY_BAR_OFFSET	0
+#define DDMI_DATA_READY_BAR_MASK	(0x1 << DDMI_DATA_READY_BAR_OFFSET)	// low is ready.
 
 //DDMI value store as big endian, you may need to do byte swap!
 #if __BYTE_ORDER == __LITTLE_ENDIAN
@@ -353,6 +357,46 @@
     return DDMI16_TO_HOST(value);
 }
 
+char *zyUtilGetPloamPassword(void){
+
+	int busfd;
+	static char ploamPassword[DDMI2_GPON_PLOAM_PWD_LENGTH+1] = {0};
+	
+	unsigned char ddmi2_data[DDMI_MAX_LENGTH];
+	memset(ddmi2_data, 0x0, sizeof(unsigned char)*DDMI_MAX_LENGTH);
+
+	// Read out DDMI value from SFP through I2C
+	busfd = zyUtil_i2c_open();
+	if( busfd < 0 )
+		return -1;
+
+	// Read DDMI2
+	if( zyUtil_i2c_setSlaveAddress(busfd, DDMI2_ADDRESS) != 0 ) {
+		zyUtil_i2c_close(busfd);
+		return -1;
+	}
+	if( zyUtil_i2c_read_register(busfd, DDMI_START_OFFSET, ddmi2_data, DDMI_MAX_LENGTH) < 0) {
+		zyUtil_i2c_close(busfd);
+		return -1;
+	}
+	zyUtil_i2c_close(busfd);
+
+	// Check if the DDMI data is ready
+	if ( ddmi2_data[DDMI2_STATUS_CONTROL_OFFSET] & DDMI_DATA_READY_BAR_MASK )
+	{
+		// true means the DDMI data is not ready.
+		printf("The DDMI data is not ready.\n");
+		return -1;
+	}
+
+	memcpy(ploamPassword, ddmi2_data+DDMI2_GPON_PLOAM_PWD_OFFSET, DDMI2_GPON_PLOAM_PWD_LENGTH);
+	DEBUG_PRINT("\nPloam password: ");_printString(ddmi2_data+DDMI2_GPON_PLOAM_PWD_OFFSET, DDMI2_GPON_PLOAM_PWD_LENGTH);
+
+	printf("sfp ploam password = %s\n", ploamPassword);
+
+	return ploamPassword;
+}
+
 int zyUtil_sfp_read_ddmi_state(sfp_ddmi_state_t *ddmi_state)
 {
     int busfd;
Index: libzyutil-1.0/zyutil_sfp.h
===================================================================
--- libzyutil-1.0.orig/zyutil_sfp.h	2020-04-08 18:13:15.991168234 +0800
+++ libzyutil-1.0/zyutil_sfp.h	2020-04-08 18:14:09.475144214 +0800
@@ -71,5 +71,7 @@
 int zyUtil_i2c_write(int fd, unsigned char reg, char *buf);
 int strHex(char *str, unsigned char reg, unsigned char *strBuff);
 #endif
+char *zyUtilGetPloamPassword(void);
+
 
 #endif
