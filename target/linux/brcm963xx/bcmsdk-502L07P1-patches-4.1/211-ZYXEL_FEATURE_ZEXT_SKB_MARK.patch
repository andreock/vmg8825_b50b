Index: linux-4.1.51/include/net/ip_fib.h
===================================================================
--- linux-4.1.51.orig/include/net/ip_fib.h	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/include/net/ip_fib.h	2019-04-18 11:28:19.711859392 +0800
@@ -143,6 +143,9 @@
 struct fib_result_nl {
 	__be32		fl_addr;   /* To be looked up*/
 	u32		fl_mark;
+#ifdef CONFIG_SBG_SKB_MARK
+	u32		fl_zextmark;
+#endif /* CONFIG_SBG_SKB_MARK */
 	unsigned char	fl_tos;
 	unsigned char   fl_scope;
 	unsigned char   tb_id_in;
Index: linux-4.1.51/include/net/flow.h
===================================================================
--- linux-4.1.51.orig/include/net/flow.h	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/include/net/flow.h	2019-04-18 11:28:19.711859392 +0800
@@ -23,6 +23,9 @@
 	int	flowic_oif;
 	int	flowic_iif;
 	__u32	flowic_mark;
+#ifdef CONFIG_SBG_SKB_MARK
+	__u32	flowic_zextmark;
+#endif /* CONFIG_SBG_SKB_MARK */
 	__u8	flowic_tos;
 	__u8	flowic_scope;
 	__u8	flowic_proto;
@@ -61,6 +64,9 @@
 #define flowi4_oif		__fl_common.flowic_oif
 #define flowi4_iif		__fl_common.flowic_iif
 #define flowi4_mark		__fl_common.flowic_mark
+#ifdef CONFIG_SBG_SKB_MARK
+#define flowi4_zextmark		__fl_common.flowic_zextmark
+#endif /* CONFIG_SBG_SKB_MARK */
 #define flowi4_tos		__fl_common.flowic_tos
 #define flowi4_scope		__fl_common.flowic_scope
 #define flowi4_proto		__fl_common.flowic_proto
@@ -81,8 +87,13 @@
 #define fl4_gre_key		uli.gre_key
 } __attribute__((__aligned__(BITS_PER_LONG/8)));
 
+
 static inline void flowi4_init_output(struct flowi4 *fl4, int oif,
+#ifdef CONFIG_SBG_SKB_MARK
+				      __u32 mark, __u32 zextmark, __u8 tos, __u8 scope,
+#else
 				      __u32 mark, __u8 tos, __u8 scope,
+#endif
 				      __u8 proto, __u8 flags,
 				      __be32 daddr, __be32 saddr,
 				      __be16 dport, __be16 sport)
@@ -90,6 +101,9 @@
 	fl4->flowi4_oif = oif;
 	fl4->flowi4_iif = LOOPBACK_IFINDEX;
 	fl4->flowi4_mark = mark;
+#ifdef CONFIG_SBG_SKB_MARK
+	fl4->flowi4_zextmark = zextmark;
+#endif /* CONFIG_SBG_SKB_MARK */
 	fl4->flowi4_tos = tos;
 	fl4->flowi4_scope = scope;
 	fl4->flowi4_proto = proto;
@@ -117,6 +131,9 @@
 #define flowi6_oif		__fl_common.flowic_oif
 #define flowi6_iif		__fl_common.flowic_iif
 #define flowi6_mark		__fl_common.flowic_mark
+#ifdef CONFIG_SBG_SKB_MARK
+#define flowi6_zextmark		__fl_common.flowic_zextmark
+#endif /* CONFIG_SBG_SKB_MARK */
 #define flowi6_tos		__fl_common.flowic_tos
 #define flowi6_scope		__fl_common.flowic_scope
 #define flowi6_proto		__fl_common.flowic_proto
@@ -140,6 +157,9 @@
 #define flowidn_oif		__fl_common.flowic_oif
 #define flowidn_iif		__fl_common.flowic_iif
 #define flowidn_mark		__fl_common.flowic_mark
+#ifdef CONFIG_SBG_SKB_MARK
+#define flowidn_zextmark		__fl_common.flowic_zextmark
+#endif /* CONFIG_SBG_SKB_MARK */
 #define flowidn_scope		__fl_common.flowic_scope
 #define flowidn_proto		__fl_common.flowic_proto
 #define flowidn_flags		__fl_common.flowic_flags
@@ -160,6 +180,9 @@
 #define flowi_oif	u.__fl_common.flowic_oif
 #define flowi_iif	u.__fl_common.flowic_iif
 #define flowi_mark	u.__fl_common.flowic_mark
+#ifdef CONFIG_SBG_SKB_MARK
+#define flowi_zextmark	u.__fl_common.flowic_zextmark
+#endif /* CONFIG_SBG_SKB_MARK */
 #define flowi_tos	u.__fl_common.flowic_tos
 #define flowi_scope	u.__fl_common.flowic_scope
 #define flowi_proto	u.__fl_common.flowic_proto
Index: linux-4.1.51/include/net/xfrm.h
===================================================================
--- linux-4.1.51.orig/include/net/xfrm.h	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/include/net/xfrm.h	2019-04-18 11:28:19.711859392 +0800
@@ -140,6 +140,9 @@
 	struct xfrm_id		id;
 	struct xfrm_selector	sel;
 	struct xfrm_mark	mark;
+#ifdef CONFIG_SBG_SKB_MARK
+	struct xfrm_mark	zextmark;
+#endif /* CONFIG_SBG_SKB_MARK */
 	u32			tfcpad;
 
 	u32			genid;
@@ -534,6 +537,9 @@
 	u32			priority;
 	u32			index;
 	struct xfrm_mark	mark;
+#ifdef CONFIG_SBG_SKB_MARK
+	struct xfrm_mark	zextmark;
+#endif /* CONFIG_SBG_SKB_MARK */
 	struct xfrm_selector	selector;
 	struct xfrm_lifetime_cfg lft;
 	struct xfrm_lifetime_cur curlft;
@@ -1776,6 +1782,27 @@
 	return ret;
 }
 
+#ifdef CONFIG_NETFILTER_XT_CONNZEXTMARK
+static inline int xfrm_zextmark_get(struct nlattr **attrs, struct xfrm_mark *m)
+{
+	if (attrs[XFRMA_ZEXTMARK])
+		memcpy(m, nla_data(attrs[XFRMA_ZEXTMARK]), sizeof(struct xfrm_mark));
+	else
+		m->v = m->m = 0;
+
+	return m->v & m->m;
+}
+
+static inline int xfrm_zextmark_put(struct sk_buff *skb, const struct xfrm_mark *m)
+{
+	int ret = 0;
+
+	if (m->m | m->v)
+		ret = nla_put(skb, XFRMA_ZEXTMARK, sizeof(struct xfrm_mark), m);
+	return ret;
+}
+#endif
+
 static inline int xfrm_tunnel_check(struct sk_buff *skb, struct xfrm_state *x,
 				    unsigned int family)
 {
Index: linux-4.1.51/include/uapi/linux/netfilter_bridge/ebt_mark_m.h
===================================================================
--- linux-4.1.51.orig/include/uapi/linux/netfilter_bridge/ebt_mark_m.h	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/include/uapi/linux/netfilter_bridge/ebt_mark_m.h	2019-04-18 11:28:19.711859392 +0800
@@ -12,5 +12,8 @@
 	__u8 bitmask;
 };
 #define EBT_MARK_MATCH "mark_m"
+#ifdef CONFIG_SBG_SKB_MARK
+#define EBT_ZEXTMARK_MATCH "zextmark_m"
+#endif /* CONFIG_SBG_SKB_MARK */
 
 #endif
Index: linux-4.1.51/include/uapi/linux/netfilter_bridge/ebt_mark_t.h
===================================================================
--- linux-4.1.51.orig/include/uapi/linux/netfilter_bridge/ebt_mark_t.h	2019-04-18 11:28:19.263859396 +0800
+++ linux-4.1.51/include/uapi/linux/netfilter_bridge/ebt_mark_t.h	2019-04-18 11:28:19.715859392 +0800
@@ -23,5 +23,8 @@
 	int target;
 };
 #define EBT_MARK_TARGET "mark"
+#ifdef CONFIG_SBG_SKB_MARK
+#define EBT_ZEXTMARK_TARGET "zextmark"
+#endif /* CONFIG_SBG_SKB_MARK */
 
 #endif
Index: linux-4.1.51/net/netfilter/Makefile
===================================================================
--- linux-4.1.51.orig/net/netfilter/Makefile	2019-04-18 11:28:19.687859392 +0800
+++ linux-4.1.51/net/netfilter/Makefile	2019-04-18 11:28:19.715859392 +0800
@@ -147,6 +147,7 @@
 obj-$(CONFIG_NETFILTER_XT_TARGET_SKIPLOG) += xt_SKIPLOG.o
 obj-$(CONFIG_NETFILTER_XT_TARGET_DC)      += xt_DC.o
 endif #BCM_KF # defined(CONFIG_BCM_KF_NETFILTER)
+obj-$(CONFIG_NETFILTER_XT_MATCH_ZEXTMARK) += xt_zextmark.o
 
 # matches
 obj-$(CONFIG_NETFILTER_XT_MATCH_ADDRTYPE) += xt_addrtype.o
Index: linux-4.1.51/net/bridge/netfilter/Kconfig
===================================================================
--- linux-4.1.51.orig/net/bridge/netfilter/Kconfig	2019-04-18 11:28:19.375859395 +0800
+++ linux-4.1.51/net/bridge/netfilter/Kconfig	2019-04-18 11:28:19.715859392 +0800
@@ -129,6 +129,16 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config BRIDGE_EBT_ZEXTMARK
+	tristate "ebt: zextmark filter support"
+	help
+	  This option adds the zextmark match, which allows matching frames based on
+	  the 'nfmark' value in the frame. This can be set by the zextmark target.
+	  This value is the same as the one used in the iptables zextmark match and
+	  target.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
+
 config BRIDGE_EBT_PKTTYPE
 	tristate "ebt: packet type filter support"
 	help
@@ -204,6 +214,16 @@
 	  target.
 
 	  To compile it as a module, choose M here.  If unsure, say N.
+
+config BRIDGE_EBT_ZEXTMARK_T
+	tristate "ebt: zextmark target support"
+	help
+	  This option adds the zextmark target, which allows marking frames by
+	  setting the 'nfmark' value in the frame.
+	  This value is the same as the one used in the iptables zextmark match and
+	  target.
+
+	  To compile it as a module, choose M here.  If unsure, say N.
 
 config BRIDGE_EBT_REDIRECT
 	tristate "ebt: redirect target support"
Index: linux-4.1.51/net/bridge/netfilter/Makefile
===================================================================
--- linux-4.1.51.orig/net/bridge/netfilter/Makefile	2019-04-18 11:28:19.375859395 +0800
+++ linux-4.1.51/net/bridge/netfilter/Makefile	2019-04-18 11:28:19.715859392 +0800
@@ -25,6 +25,7 @@
 obj-$(CONFIG_BRIDGE_EBT_IP6) += ebt_ip6.o
 obj-$(CONFIG_BRIDGE_EBT_LIMIT) += ebt_limit.o
 obj-$(CONFIG_BRIDGE_EBT_MARK) += ebt_mark_m.o
+obj-$(CONFIG_BRIDGE_EBT_ZEXTMARK) += ebt_zextmark_m.o
 obj-$(CONFIG_BRIDGE_EBT_PKTTYPE) += ebt_pkttype.o
 obj-$(CONFIG_BRIDGE_EBT_STP) += ebt_stp.o
 obj-$(CONFIG_BRIDGE_EBT_VLAN) += ebt_vlan.o
@@ -36,6 +37,7 @@
 # targets
 obj-$(CONFIG_BRIDGE_EBT_ARPREPLY) += ebt_arpreply.o
 obj-$(CONFIG_BRIDGE_EBT_MARK_T) += ebt_mark.o
+obj-$(CONFIG_BRIDGE_EBT_ZEXTMARK_T) += ebt_zextmark.o
 obj-$(CONFIG_BRIDGE_EBT_DNAT) += ebt_dnat.o
 obj-$(CONFIG_BRIDGE_EBT_REDIRECT) += ebt_redirect.o
 obj-$(CONFIG_BRIDGE_EBT_SNAT) += ebt_snat.o
Index: linux-4.1.51/net/bridge/netfilter/ebt_zextmark.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-4.1.51/net/bridge/netfilter/ebt_zextmark.c	2019-04-18 14:12:22.174560445 +0800
@@ -0,0 +1,187 @@
+/*
+ *  ebt_mark
+ *
+ *	Authors:
+ *	Bart De Schuymer <bdschuym@pandora.be>
+ *
+ *  July, 2002
+ *
+ */
+
+/* The mark target can be used in any chain,
+ * I believe adding a mangle table just for marking is total overkill.
+ * Marking a frame doesn't really change anything in the frame anyway.
+ */
+
+#include <linux/module.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_bridge/ebtables.h>
+#include <linux/netfilter_bridge/ebt_mark_t.h>
+
+#include "zld/zld_cb_data.h"
+
+static unsigned int
+ebt_mark_tg(struct sk_buff *skb, const struct xt_action_param *par)
+{
+	const struct ebt_mark_t_info *info = par->targinfo;
+	int action = info->target & -16;
+
+	if (action == MARK_SET_VALUE)
+		ZLD_CB_DATA(skb)->zextmark = info->mark;
+	else if (action == MARK_OR_VALUE)
+		ZLD_CB_DATA(skb)->zextmark |= info->mark;
+	else if (action == MARK_AND_VALUE)
+		ZLD_CB_DATA(skb)->zextmark &= info->mark;
+#if !defined(CONFIG_BCM_KF_NETFILTER)
+	else
+		ZLD_CB_DATA(skb)->zextmark ^= info->mark;
+#else
+	else if (action == MARK_XOR_VALUE)
+		ZLD_CB_DATA(skb)->zextmark ^= info->mark;
+	else
+   {
+		skb->vtag = (unsigned short)(info->mark);
+
+      /* if the 8021p priority field (bits 0-3) of skb->vtag is not zero, we need
+       * to do p-bit marking.
+       */
+      if (skb->vtag & 0xf)
+      {
+         unsigned short TCI = 0;
+
+         /* if this is a vlan frame, we want to re-mark its p-bit with the 8021p
+          * priority in skb->vtag.
+          * if this is not a vlan frame, we want to add a 8021p tag to it, with
+          * vid=0 and p-bit=the 8021p priority in skb->vtag.
+          */
+	      if ((skb->protocol == __constant_htons(ETH_P_8021Q)))
+	      {
+   	      struct vlan_hdr *frame = (struct vlan_hdr *)(skb_network_header(skb));
+
+		      TCI = ntohs(frame->h_vlan_TCI);
+
+            /* Since the 8021p priority value in vtag had been incremented by 1,
+             * we need to minus 1 from it to get the exact value.
+             */
+            TCI = (TCI & 0x1fff) | (((skb->vtag & 0xf) - 1) << 13);
+
+		      frame->h_vlan_TCI = htons(TCI);
+   	   }
+#if 0 /* ZyXEL QoS, change VLAM header process to vlanCtl driver instead of ebtables module, John (porting from MSTC)*/
+         else
+         {
+            if ((skb->mac_header - skb->head) < VLAN_HLEN)
+            {
+               printk("ebt_mark_tg: No headroom for VLAN tag. Marking is not done.\n");
+            }
+            else
+            {
+   	         struct vlan_ethhdr *ethHeader;
+
+               skb->protocol = __constant_htons(ETH_P_8021Q);
+               skb->mac_header -= VLAN_HLEN;
+               skb->network_header -= VLAN_HLEN;
+               skb->data -= VLAN_HLEN;
+	            skb->len  += VLAN_HLEN;
+
+               /* Move the mac addresses to the beginning of the new header. */
+               memmove(skb->mac_header, skb->mac_header + VLAN_HLEN, 2 * ETH_ALEN);
+
+               ethHeader = (struct vlan_ethhdr *)(skb->mac_header);
+
+               ethHeader->h_vlan_proto = __constant_htons(ETH_P_8021Q);
+
+               /* Since the 8021p priority value in vtag had been incremented by 1,
+                * we need to minus 1 from it to get the exact value.
+                */
+               TCI = (TCI & 0x1fff) | (((skb->vtag & 0xf) - 1) << 13);
+
+               ethHeader->h_vlan_TCI = htons(TCI);
+            }
+         }
+         skb->vtag = 0;
+#endif
+      }
+   }
+#endif // CONFIG_BCM_KF_NETFILTER
+
+	return info->target | ~EBT_VERDICT_BITS;
+}
+
+static int ebt_mark_tg_check(const struct xt_tgchk_param *par)
+{
+	const struct ebt_mark_t_info *info = par->targinfo;
+	int tmp;
+
+	tmp = info->target | ~EBT_VERDICT_BITS;
+	if (BASE_CHAIN && tmp == EBT_RETURN)
+		return -EINVAL;
+	if (tmp < -NUM_STANDARD_TARGETS || tmp >= 0)
+		return -EINVAL;
+	tmp = info->target & ~EBT_VERDICT_BITS;
+	if (tmp != MARK_SET_VALUE && tmp != MARK_OR_VALUE &&
+#if defined(CONFIG_BCM_KF_NETFILTER)
+	    tmp != MARK_AND_VALUE && tmp != MARK_XOR_VALUE &&
+            tmp != VTAG_SET_VALUE)
+#else
+	    tmp != MARK_AND_VALUE && tmp != MARK_XOR_VALUE)
+#endif
+		return -EINVAL;
+	return 0;
+}
+#ifdef CONFIG_COMPAT
+struct compat_ebt_mark_t_info {
+	compat_ulong_t mark;
+	compat_uint_t target;
+};
+
+static void mark_tg_compat_from_user(void *dst, const void *src)
+{
+	const struct compat_ebt_mark_t_info *user = src;
+	struct ebt_mark_t_info *kern = dst;
+
+	kern->mark = user->mark;
+	kern->target = user->target;
+}
+
+static int mark_tg_compat_to_user(void __user *dst, const void *src)
+{
+	struct compat_ebt_mark_t_info __user *user = dst;
+	const struct ebt_mark_t_info *kern = src;
+
+	if (put_user(kern->mark, &user->mark) ||
+	    put_user(kern->target, &user->target))
+		return -EFAULT;
+	return 0;
+}
+#endif
+
+static struct xt_target ebt_mark_tg_reg __read_mostly = {
+	.name		= "zextmark",
+	.revision	= 0,
+	.family		= NFPROTO_BRIDGE,
+	.target		= ebt_mark_tg,
+	.checkentry	= ebt_mark_tg_check,
+	.targetsize	= sizeof(struct ebt_mark_t_info),
+#ifdef CONFIG_COMPAT
+	.compatsize	= sizeof(struct compat_ebt_mark_t_info),
+	.compat_from_user = mark_tg_compat_from_user,
+	.compat_to_user	= mark_tg_compat_to_user,
+#endif
+	.me		= THIS_MODULE,
+};
+
+static int __init ebt_mark_init(void)
+{
+	return xt_register_target(&ebt_mark_tg_reg);
+}
+
+static void __exit ebt_mark_fini(void)
+{
+	xt_unregister_target(&ebt_mark_tg_reg);
+}
+
+module_init(ebt_mark_init);
+module_exit(ebt_mark_fini);
+MODULE_DESCRIPTION("Ebtables: Packet zextmark modification");
+MODULE_LICENSE("GPL");
Index: linux-4.1.51/net/bridge/netfilter/ebt_zextmark_m.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ linux-4.1.51/net/bridge/netfilter/ebt_zextmark_m.c	2019-04-18 11:28:19.715859392 +0800
@@ -0,0 +1,100 @@
+/*
+ *  ebt_mark_m
+ *
+ *	Authors:
+ *	Bart De Schuymer <bdschuym@pandora.be>
+ *
+ *  July, 2002
+ *
+ */
+#include <linux/module.h>
+#include <linux/netfilter/x_tables.h>
+#include <linux/netfilter_bridge/ebtables.h>
+#include <linux/netfilter_bridge/ebt_mark_m.h>
+
+#include "zld/zld_cb_data.h"
+
+static bool
+ebt_mark_mt(const struct sk_buff *skb, struct xt_action_param *par)
+{
+	const struct ebt_mark_m_info *info = par->matchinfo;
+
+	if (info->bitmask & EBT_MARK_OR)
+		return !!(ZLD_CB_DATA(skb)->zextmark & info->mask) ^ info->invert;
+	return ((ZLD_CB_DATA(skb)->zextmark & info->mask) == info->mark) ^ info->invert;
+}
+
+static int ebt_mark_mt_check(const struct xt_mtchk_param *par)
+{
+	const struct ebt_mark_m_info *info = par->matchinfo;
+
+	if (info->bitmask & ~EBT_MARK_MASK)
+		return -EINVAL;
+	if ((info->bitmask & EBT_MARK_OR) && (info->bitmask & EBT_MARK_AND))
+		return -EINVAL;
+	if (!info->bitmask)
+		return -EINVAL;
+	return 0;
+}
+
+
+#ifdef CONFIG_COMPAT
+struct compat_ebt_mark_m_info {
+	compat_ulong_t mark, mask;
+	uint8_t invert, bitmask;
+};
+
+static void mark_mt_compat_from_user(void *dst, const void *src)
+{
+	const struct compat_ebt_mark_m_info *user = src;
+	struct ebt_mark_m_info *kern = dst;
+
+	kern->mark = user->mark;
+	kern->mask = user->mask;
+	kern->invert = user->invert;
+	kern->bitmask = user->bitmask;
+}
+
+static int mark_mt_compat_to_user(void __user *dst, const void *src)
+{
+	struct compat_ebt_mark_m_info __user *user = dst;
+	const struct ebt_mark_m_info *kern = src;
+
+	if (put_user(kern->mark, &user->mark) ||
+	    put_user(kern->mask, &user->mask) ||
+	    put_user(kern->invert, &user->invert) ||
+	    put_user(kern->bitmask, &user->bitmask))
+		return -EFAULT;
+	return 0;
+}
+#endif
+
+static struct xt_match ebt_mark_mt_reg __read_mostly = {
+	.name		= "zextmark_m",
+	.revision	= 0,
+	.family		= NFPROTO_BRIDGE,
+	.match		= ebt_mark_mt,
+	.checkentry	= ebt_mark_mt_check,
+	.matchsize	= sizeof(struct ebt_mark_m_info),
+#ifdef CONFIG_COMPAT
+	.compatsize	= sizeof(struct compat_ebt_mark_m_info),
+	.compat_from_user = mark_mt_compat_from_user,
+	.compat_to_user	= mark_mt_compat_to_user,
+#endif
+	.me		= THIS_MODULE,
+};
+
+static int __init ebt_mark_m_init(void)
+{
+	return xt_register_match(&ebt_mark_mt_reg);
+}
+
+static void __exit ebt_mark_m_fini(void)
+{
+	xt_unregister_match(&ebt_mark_mt_reg);
+}
+
+module_init(ebt_mark_m_init);
+module_exit(ebt_mark_m_fini);
+MODULE_DESCRIPTION("Ebtables: Packet zextmark match");
+MODULE_LICENSE("GPL");
Index: linux-4.1.51/net/ipv4/netfilter.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/netfilter.c	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/net/ipv4/netfilter.c	2019-04-18 11:28:19.715859392 +0800
@@ -16,6 +16,10 @@
 #include <net/ip.h>
 #include <net/netfilter/nf_queue.h>
 
+#ifdef CONFIG_SBG_SKB_MARK
+#include "zld/zld_cb_data.h"
+#endif /* CONFIG_SBG_SKB_MARK */
+
 /* route_me_harder function, used by iptable_nat, iptable_mangle + ip_queue */
 int ip_route_me_harder(struct sk_buff *skb, unsigned int addr_type)
 {
@@ -42,6 +46,9 @@
 	fl4.flowi4_tos = RT_TOS(iph->tos);
 	fl4.flowi4_oif = skb->sk ? skb->sk->sk_bound_dev_if : 0;
 	fl4.flowi4_mark = skb->mark;
+#ifdef CONFIG_SBG_SKB_MARK
+	fl4.flowi4_zextmark = ZLD_CB_DATA(skb)->zextmark;
+#endif /* CONFIG_SBG_SKB_MARK */
 	fl4.flowi4_flags = flags;
 	rt = ip_route_output_key(net, &fl4);
 	if (IS_ERR(rt))
Index: linux-4.1.51/net/ipv4/netfilter/ipt_rpfilter.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/netfilter/ipt_rpfilter.c	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/net/ipv4/netfilter/ipt_rpfilter.c	2019-04-18 11:28:19.715859392 +0800
@@ -95,6 +95,9 @@
 	flow.saddr = rpfilter_get_saddr(iph->daddr);
 	flow.flowi4_oif = 0;
 	flow.flowi4_mark = info->flags & XT_RPFILTER_VALID_MARK ? skb->mark : 0;
+#ifdef CONFIG_SBG_SKB_MARK
+	flow.flowi4_zextmark = info->flags & XT_RPFILTER_VALID_MARK ? ZLD_CB_DATA(skb)->zextmark : 0;
+#endif /* CONFIG_SBG_SKB_MARK */
 	flow.flowi4_tos = RT_TOS(iph->tos);
 	flow.flowi4_scope = RT_SCOPE_UNIVERSE;
 
Index: linux-4.1.51/include/net/fib_rules.h
===================================================================
--- linux-4.1.51.orig/include/net/fib_rules.h	2019-04-18 11:28:19.703859392 +0800
+++ linux-4.1.51/include/net/fib_rules.h	2019-04-18 11:28:19.715859392 +0800
@@ -82,7 +82,7 @@
 	struct net		*fro_net;
 	struct rcu_head		rcu;
 };
-#ifdef NETFILTER_XT_CONNZEXTMARK
+#ifdef CONFIG_NETFILTER_XT_CONNZEXTMARK
 #define FRA_GENERIC_POLICY \
 	[FRA_IIFNAME]	= { .type = NLA_STRING, .len = IFNAMSIZ - 1 }, \
 	[FRA_OIFNAME]	= { .type = NLA_STRING, .len = IFNAMSIZ - 1 }, \
Index: linux-4.1.51/include/uapi/linux/fib_rules.h
===================================================================
--- linux-4.1.51.orig/include/uapi/linux/fib_rules.h	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/include/uapi/linux/fib_rules.h	2019-04-18 11:28:19.715859392 +0800
@@ -49,6 +49,8 @@
 	FRA_TABLE,	/* Extended table id */
 	FRA_FWMASK,	/* mask for netfilter mark */
 	FRA_OIFNAME,
+	FRA_ZEXTMARK,	/* zextmark */
+	FRA_ZEXTMASK,	/* mask for netfilter zextmark */
 	__FRA_MAX
 };
 
Index: linux-4.1.51/include/linux/skbuff.h
===================================================================
--- linux-4.1.51.orig/include/linux/skbuff.h	2019-04-18 11:28:19.683859392 +0800
+++ linux-4.1.51/include/linux/skbuff.h	2019-04-18 11:28:19.715859392 +0800
@@ -1050,6 +1050,9 @@
 	atomic_t		users;
 };
 
+#ifdef CONFIG_ZLD_SKB_ZLD_CB
+#include "zld/zld_cb_data.h"
+#endif
 #ifdef __KERNEL__
 /*
  *	Handling routines are only of interest to the kernel
Index: linux-4.1.51/include/net/route.h
===================================================================
--- linux-4.1.51.orig/include/net/route.h	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/include/net/route.h	2019-04-18 11:39:50.052393560 +0800
@@ -139,7 +139,11 @@
 						   __be16 dport, __be16 sport,
 						   __u8 proto, __u8 tos, int oif)
 {
+#ifdef CONFIG_SBG_SKB_MARK
+	flowi4_init_output(fl4, oif, sk ? sk->sk_mark : 0, 0, tos,
+#else
 	flowi4_init_output(fl4, oif, sk ? sk->sk_mark : 0, tos,
+#endif
 			   RT_SCOPE_UNIVERSE, proto,
 			   sk ? inet_sk_flowi_flags(sk) : 0,
 			   daddr, saddr, dport, sport);
@@ -250,8 +254,15 @@
 	if (inet_sk(sk)->transparent)
 		flow_flags |= FLOWI_FLAG_ANYSRC;
 
+
+#ifdef CONFIG_SBG_SKB_MARK
+	/* socket don't support extension mark in this stage */
+	flowi4_init_output(fl4, oif, sk->sk_mark, 0,tos, RT_SCOPE_UNIVERSE,
+			   protocol, flow_flags, dst, src, dport, sport);
+#else
 	flowi4_init_output(fl4, oif, sk->sk_mark, tos, RT_SCOPE_UNIVERSE,
 			   protocol, flow_flags, dst, src, dport, sport);
+#endif
 }
 
 static inline struct rtable *ip_route_connect(struct flowi4 *fl4,
Index: linux-4.1.51/include/uapi/linux/rtnetlink.h
===================================================================
--- linux-4.1.51.orig/include/uapi/linux/rtnetlink.h	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/include/uapi/linux/rtnetlink.h	2019-04-18 11:28:19.715859392 +0800
@@ -304,6 +304,7 @@
 	RTA_MP_ALGO, /* no longer used */
 	RTA_TABLE,
 	RTA_MARK,
+	RTA_ZEXTMARK,
 	RTA_MFC_STATS,
 	RTA_VIA,
 	RTA_NEWDST,
Index: linux-4.1.51/net/ipv4/inet_connection_sock.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/inet_connection_sock.c	2019-04-18 11:28:19.291859396 +0800
+++ linux-4.1.51/net/ipv4/inet_connection_sock.c	2019-04-18 11:28:19.715859392 +0800
@@ -412,6 +412,9 @@
 	struct rtable *rt;
 
 	flowi4_init_output(fl4, ireq->ir_iif, ireq->ir_mark,
+#ifdef CONFIG_SBG_SKB_MARK
+			0,
+#endif
 			   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,
 			   sk->sk_protocol, inet_sk_flowi_flags(sk),
 			   (opt && opt->opt.srr) ? opt->opt.faddr : ireq->ir_rmt_addr,
@@ -449,6 +452,9 @@
 	rcu_read_lock();
 	opt = rcu_dereference(newinet->inet_opt);
 	flowi4_init_output(fl4, ireq->ir_iif, ireq->ir_mark,
+#ifdef CONFIG_SBG_SKB_MARK
+			0,
+#endif
 			   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,
 			   sk->sk_protocol, inet_sk_flowi_flags(sk),
 			   (opt && opt->opt.srr) ? opt->opt.faddr : ireq->ir_rmt_addr,
Index: linux-4.1.51/net/ipv4/ip_output.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/ip_output.c	2019-04-18 11:28:19.291859396 +0800
+++ linux-4.1.51/net/ipv4/ip_output.c	2019-04-18 15:25:28.712325312 +0800
@@ -1568,6 +1568,9 @@
 
 	flowi4_init_output(&fl4, arg->bound_dev_if,
 			   IP4_REPLY_MARK(net, skb->mark),
+#ifdef CONFIG_SBG_SKB_MARK
+			   IP4_REPLY_MARK(net, ZLD_CB_DATA(skb)->zextmark),
+#endif
 			   RT_TOS(arg->tos),
 			   RT_SCOPE_UNIVERSE, ip_hdr(skb)->protocol,
 			   ip_reply_arg_flowi_flags(arg),
Index: linux-4.1.51/net/ipv4/ping.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/ping.c	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/net/ipv4/ping.c	2019-04-18 15:36:35.936580206 +0800
@@ -793,7 +793,14 @@
 	} else if (!ipc.oif)
 		ipc.oif = inet->uc_index;
 
-	flowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,
+	flowi4_init_output(&fl4, ipc.oif, sk->sk_mark,
+#ifdef CONFIG_SBG_SKB_MARK
+	/* FIXME: Horace.
+	     We don't support zextmark in socket.
+	*/
+			  0,
+#endif
+		tos,
 			   RT_SCOPE_UNIVERSE, sk->sk_protocol,
 			   inet_sk_flowi_flags(sk), faddr, saddr, 0, 0);
 
Index: linux-4.1.51/net/ipv4/raw.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/raw.c	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/net/ipv4/raw.c	2019-04-18 15:30:11.971525212 +0800
@@ -595,7 +595,14 @@
 	} else if (!ipc.oif)
 		ipc.oif = inet->uc_index;
 
-	flowi4_init_output(&fl4, ipc.oif, sk->sk_mark, tos,
+	flowi4_init_output(&fl4, ipc.oif, sk->sk_mark,
+#ifdef CONFIG_SBG_SKB_MARK
+/* FIXME: Horace
+    Socket don't support extension mark bit now
+*/
+			 0,
+#endif
+		tos,
 			   RT_SCOPE_UNIVERSE,
 			   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,
 			   inet_sk_flowi_flags(sk) |
Index: linux-4.1.51/net/ipv4/route.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/route.c	2019-04-18 11:28:19.295859395 +0800
+++ linux-4.1.51/net/ipv4/route.c	2019-04-19 09:11:15.969282893 +0800
@@ -505,7 +505,11 @@
 static void __build_flow_key(struct flowi4 *fl4, const struct sock *sk,
 			     const struct iphdr *iph,
 			     int oif, u8 tos,
-			     u8 prot, u32 mark, int flow_flags)
+			     u8 prot, u32 mark,
+#ifdef CONFIG_SBG_SKB_MARK
+				u32 zextmark,
+#endif
+				 int flow_flags)
 {
 	if (sk) {
 		const struct inet_sock *inet = inet_sk(sk);
@@ -515,7 +519,11 @@
 		tos = RT_CONN_FLAGS(sk);
 		prot = inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol;
 	}
-	flowi4_init_output(fl4, oif, mark, tos,
+	flowi4_init_output(fl4, oif, mark,
+#ifdef CONFIG_SBG_SKB_MARK
+			  zextmark,
+#endif
+		tos,
 			   RT_SCOPE_UNIVERSE, prot,
 			   flow_flags,
 			   iph->daddr, iph->saddr, 0, 0);
@@ -529,8 +537,13 @@
 	u8 tos = RT_TOS(iph->tos);
 	u8 prot = iph->protocol;
 	u32 mark = skb->mark;
-
+#ifdef CONFIG_SBG_SKB_MARK
+	u32 zextmark = ZLD_CB_DATA(skb)->zextmark;
+	__build_flow_key(fl4, sk, iph, oif, tos, prot, mark, zextmark, 0);
+#else
 	__build_flow_key(fl4, sk, iph, oif, tos, prot, mark, 0);
+#endif /* CONFIG_SBG_SKB_MARK */
+
 }
 
 static void build_sk_flow_key(struct flowi4 *fl4, const struct sock *sk)
@@ -544,6 +557,9 @@
 	if (inet_opt && inet_opt->opt.srr)
 		daddr = inet_opt->opt.faddr;
 	flowi4_init_output(fl4, sk->sk_bound_dev_if, sk->sk_mark,
+#ifdef CONFIG_SBG_SKB_MARK
+			  0,
+#endif
 			   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE,
 			   inet->hdrincl ? IPPROTO_RAW : sk->sk_protocol,
 			   inet_sk_flowi_flags(sk),
@@ -799,7 +815,13 @@
 
 	rt = (struct rtable *) dst;
 
+#ifdef CONFIG_SBG_SKB_MARK
+	u32 zextmark = ZLD_CB_DATA(skb)->zextmark;
+	__build_flow_key(&fl4, sk, iph, oif, tos, prot, mark, zextmark, 0);
+#else
 	__build_flow_key(&fl4, sk, iph, oif, tos, prot, mark, 0);
+#endif /* CONFIG_SBG_SKB_MARK */
+
 	__ip_do_redirect(rt, skb, &fl4, true);
 }
 
@@ -1014,8 +1036,22 @@
 	if (!mark)
 		mark = IP4_REPLY_MARK(net, skb->mark);
 
+#ifdef CONFIG_SBG_SKB_MARK
+	{
+	    /* FIXME: Horace
+		  It seems that there are no api to send the mark value. Thus we
+		 assumpt the zextmark be zero, too. It can avoid modify too much files.
+		 */
+		u32 zextmark = 0;
+	if (!zextmark)
+		zextmark = IP4_REPLY_MARK(net, ZLD_CB_DATA(skb)->zextmark);
+	__build_flow_key(&fl4, NULL, iph, oif,
+			 RT_TOS(iph->tos), protocol, mark, 0, flow_flags);
+	}
+#else
 	__build_flow_key(&fl4, NULL, iph, oif,
 			 RT_TOS(iph->tos), protocol, mark, flow_flags);
+#endif /* CONFIG_SBG_SKB_MARK */
 	rt = __ip_route_output_key(net, &fl4);
 	if (!IS_ERR(rt)) {
 		__ip_rt_update_pmtu(rt, &fl4, mtu);
@@ -1030,7 +1066,13 @@
 	struct flowi4 fl4;
 	struct rtable *rt;
 
+#ifdef CONFIG_SBG_SKB_MARK
+	__build_flow_key(&fl4, sk, iph, 0, 0, 0, 0, 0, 0);
+	if (!fl4.flowi4_zextmark)
+		fl4.flowi4_zextmark = IP4_REPLY_MARK(sock_net(sk), ZLD_CB_DATA(skb)->zextmark);
+#else
 	__build_flow_key(&fl4, sk, iph, 0, 0, 0, 0, 0);
+#endif /* CONFIG_SBG_SKB_MARK */
 
 	if (!fl4.flowi4_mark)
 		fl4.flowi4_mark = IP4_REPLY_MARK(sock_net(sk), skb->mark);
@@ -1061,8 +1103,11 @@
 		__ipv4_sk_update_pmtu(skb, sk, mtu);
 		goto out;
 	}
-
+#ifdef CONFIG_SBG_SKB_MARK
+	__build_flow_key(&fl4, sk, iph, 0, 0, 0, 0, 0, 0);
+#else
 	__build_flow_key(&fl4, sk, iph, 0, 0, 0, 0, 0);
+#endif /* CONFIG_SBG_SKB_MARK */
 
 	rt = (struct rtable *)odst;
 	if (odst->obsolete && !odst->ops->check(odst, 0)) {
@@ -1102,8 +1147,17 @@
 	struct flowi4 fl4;
 	struct rtable *rt;
 
+#ifdef CONFIG_SBG_SKB_MARK
+	/* FIXME: Horace
+	   From the caller, the mark field are all zero. Thus we assumpt the zextmark to zero, too
+	 */
+	__build_flow_key(&fl4, NULL, iph, oif,
+			 RT_TOS(iph->tos), protocol, mark, 0, flow_flags);
+#else
 	__build_flow_key(&fl4, NULL, iph, oif,
 			 RT_TOS(iph->tos), protocol, mark, flow_flags);
+#endif /* CONFIG_SBG_SKB_MARK */
+
 	rt = __ip_route_output_key(net, &fl4);
 	if (!IS_ERR(rt)) {
 		__ip_do_redirect(rt, skb, &fl4, false);
@@ -1118,7 +1172,13 @@
 	struct flowi4 fl4;
 	struct rtable *rt;
 
+#ifdef CONFIG_SBG_SKB_MARK
+	__build_flow_key(&fl4, sk, iph, 0, 0, 0, 0, 0, 0);
+#else
 	__build_flow_key(&fl4, sk, iph, 0, 0, 0, 0, 0);
+#endif /* CONFIG_SBG_SKB_MARK */
+
+
 	rt = __ip_route_output_key(sock_net(sk), &fl4);
 	if (!IS_ERR(rt)) {
 		__ip_do_redirect(rt, skb, &fl4, false);
@@ -1194,6 +1254,9 @@
 		fl4.flowi4_oif = rt->dst.dev->ifindex;
 		fl4.flowi4_iif = skb->dev->ifindex;
 		fl4.flowi4_mark = skb->mark;
+#ifdef CONFIG_SBG_SKB_MARK
+		fl4.flowi4_zextmark = ZLD_CB_DATA(skb)->zextmark;
+#endif /* CONFIG_SBG_SKB_MARK */
 
 		rcu_read_lock();
 		if (fib_lookup(dev_net(rt->dst.dev), &fl4, &res) == 0)
@@ -1761,6 +1824,9 @@
 	fl4.flowi4_oif = 0;
 	fl4.flowi4_iif = dev->ifindex;
 	fl4.flowi4_mark = skb->mark;
+#ifdef CONFIG_SBG_SKB_MARK
+		fl4.flowi4_zextmark = ZLD_CB_DATA(skb)->zextmark;
+#endif /* CONFIG_SBG_SKB_MARK */
 	fl4.flowi4_tos = tos;
 	fl4.flowi4_scope = RT_SCOPE_UNIVERSE;
 	fl4.daddr = daddr;
@@ -2434,6 +2500,12 @@
 	    nla_put_u32(skb, RTA_MARK, fl4->flowi4_mark))
 		goto nla_put_failure;
 
+#ifdef CONFIG_SBG_SKB_MARK
+	if (fl4->flowi4_zextmark &&
+	    nla_put_u32(skb, RTA_ZEXTMARK, fl4->flowi4_zextmark))
+		goto nla_put_failure;
+#endif /* CONFIG_SBG_SKB_MARK */
+
 	error = rt->dst.error;
 
 	if (rt_is_input_route(rt)) {
@@ -2489,6 +2561,9 @@
 	u32 iif;
 	int err;
 	int mark;
+#ifdef CONFIG_SBG_SKB_MARK
+	u32 zextmark;
+#endif
 	struct sk_buff *skb;
 
 	err = nlmsg_parse(nlh, sizeof(*rtm), tb, RTA_MAX, rtm_ipv4_policy);
@@ -2524,6 +2599,10 @@
 	fl4.flowi4_tos = rtm->rtm_tos;
 	fl4.flowi4_oif = tb[RTA_OIF] ? nla_get_u32(tb[RTA_OIF]) : 0;
 	fl4.flowi4_mark = mark;
+#ifdef CONFIG_SBG_SKB_MARK
+	zextmark = tb[RTA_ZEXTMARK] ? nla_get_u32(tb[RTA_ZEXTMARK]) : 0;
+	fl4.flowi4_zextmark = zextmark;
+#endif
 
 	if (iif) {
 		struct net_device *dev;
@@ -2537,6 +2616,9 @@
 		skb->protocol	= htons(ETH_P_IP);
 		skb->dev	= dev;
 		skb->mark	= mark;
+#ifdef CONFIG_SBG_SKB_MARK
+		ZLD_CB_DATA(skb)->zextmark = zextmark;
+#endif
 		local_bh_disable();
 		err = ip_route_input(skb, dst, src, rtm->rtm_tos, dev);
 		local_bh_enable();
Index: linux-4.1.51/net/ipv4/syncookies.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/syncookies.c	2019-04-18 11:28:19.295859395 +0800
+++ linux-4.1.51/net/ipv4/syncookies.c	2019-04-18 11:28:19.715859392 +0800
@@ -426,6 +426,9 @@
 	 * no easy way to do this.
 	 */
 	flowi4_init_output(&fl4, sk->sk_bound_dev_if, ireq->ir_mark,
+#ifdef CONFIG_SBG_SKB_MARK
+			 0,
+#endif
 			   RT_CONN_FLAGS(sk), RT_SCOPE_UNIVERSE, IPPROTO_TCP,
 			   inet_sk_flowi_flags(sk),
 			   opt->srr ? opt->faddr : ireq->ir_rmt_addr,
Index: linux-4.1.51/net/ipv4/udp.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/udp.c	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/net/ipv4/udp.c	2019-04-18 11:28:19.715859392 +0800
@@ -1017,7 +1017,11 @@
 		struct net *net = sock_net(sk);
 
 		fl4 = &fl4_stack;
-		flowi4_init_output(fl4, ipc.oif, sk->sk_mark, tos,
+		flowi4_init_output(fl4, ipc.oif, sk->sk_mark,
+#ifdef CONFIG_SBG_SKB_MARK
+			  0,
+#endif
+		tos,
 				   RT_SCOPE_UNIVERSE, sk->sk_protocol,
 				   inet_sk_flowi_flags(sk),
 				   faddr, saddr, dport, inet->inet_sport);
Index: linux-4.1.51/net/core/fib_rules.c
===================================================================
--- linux-4.1.51.orig/net/core/fib_rules.c	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/net/core/fib_rules.c	2019-04-18 11:28:19.719859392 +0800
@@ -186,6 +186,11 @@
 	if ((rule->mark ^ fl->flowi_mark) & rule->mark_mask)
 		goto out;
 
+#ifdef CONFIG_SBG_SKB_MARK
+	if ((rule->zextmark ^ fl->flowi_zextmark) & rule->zextmark_mask)
+		goto out;
+#endif
+
 	ret = ops->match(rule, fl, flags);
 out:
 	return (rule->flags & FIB_RULE_INVERT) ? !ret : ret;
@@ -330,6 +335,20 @@
 	if (tb[FRA_FWMASK])
 		rule->mark_mask = nla_get_u32(tb[FRA_FWMASK]);
 
+#ifdef CONFIG_SBG_SKB_MARK
+	if (tb[FRA_ZEXTMARK]) {
+		rule->zextmark = nla_get_u32(tb[FRA_ZEXTMARK]);
+		if (rule->zextmark)
+			/* compatibility: if the mark value is non-zero all bits
+			 * are compared unless a mask is explicitly specified.
+			 */
+			rule->zextmark_mask = 0xFFFFFFFF;
+	}
+
+	if (tb[FRA_ZEXTMASK])
+		rule->zextmark_mask = nla_get_u32(tb[FRA_ZEXTMASK]);
+#endif
+
 	rule->action = frh->action;
 	rule->flags = frh->flags;
 	rule->table = frh_get_table(frh, tb);
@@ -473,6 +492,16 @@
 		    (rule->mark_mask != nla_get_u32(tb[FRA_FWMASK])))
 			continue;
 
+#ifdef CONFIG_SBG_SKB_MARK
+		if (tb[FRA_ZEXTMARK] &&
+		    (rule->zextmark != nla_get_u32(tb[FRA_ZEXTMARK])))
+			continue;
+
+		if (tb[FRA_ZEXTMASK] &&
+		    (rule->zextmark_mask != nla_get_u32(tb[FRA_ZEXTMASK])))
+			continue;
+#endif
+
 		if (!ops->compare(rule, frh, tb))
 			continue;
 
@@ -534,9 +563,14 @@
 			 + nla_total_size(4) /* FRA_TABLE */
 			 + nla_total_size(4) /* FRA_SUPPRESS_PREFIXLEN */
 			 + nla_total_size(4) /* FRA_SUPPRESS_IFGROUP */
+#ifdef CONFIG_SBG_SKB_MARK
+			 + nla_total_size(4) /* FRA_ZEXTMARK */
+			 + nla_total_size(4) /* FRA_ZEXTMASK */
+#endif
 			 + nla_total_size(4) /* FRA_FWMARK */
 			 + nla_total_size(4); /* FRA_FWMASK */
 
+
 	if (ops->nlmsg_payload)
 		payload += ops->nlmsg_payload(rule);
 
@@ -590,6 +624,12 @@
 	     nla_put_u32(skb, FRA_FWMARK, rule->mark)) ||
 	    ((rule->mark_mask || rule->mark) &&
 	     nla_put_u32(skb, FRA_FWMASK, rule->mark_mask)) ||
+#ifdef CONFIG_SBG_SKB_MARK
+	    (rule->zextmark &&
+	     nla_put_u32(skb, FRA_ZEXTMARK, rule->zextmark)) ||
+	    ((rule->zextmark_mask || rule->zextmark) &&
+	     nla_put_u32(skb, FRA_ZEXTMASK, rule->zextmark_mask)) ||
+#endif
 	    (rule->target &&
 	     nla_put_u32(skb, FRA_GOTO, rule->target)))
 		goto nla_put_failure;
Index: linux-4.1.51/net/decnet/dn_route.c
===================================================================
--- linux-4.1.51.orig/net/decnet/dn_route.c	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/net/decnet/dn_route.c	2019-04-18 11:28:19.719859392 +0800
@@ -318,6 +318,9 @@
 	return ((fl1->daddr ^ fl2->daddr) |
 		(fl1->saddr ^ fl2->saddr) |
 		(fl1->flowidn_mark ^ fl2->flowidn_mark) |
+#ifdef CONFIG_SBG_SKB_MARK
+		(fl1->flowidn_zextmark ^ fl2->flowidn_zextmark) |
+#endif
 		(fl1->flowidn_scope ^ fl2->flowidn_scope) |
 		(fl1->flowidn_oif ^ fl2->flowidn_oif) |
 		(fl1->flowidn_iif ^ fl2->flowidn_iif)) == 0;
@@ -961,6 +964,9 @@
 		.saddr = oldflp->saddr,
 		.flowidn_scope = RT_SCOPE_UNIVERSE,
 		.flowidn_mark = oldflp->flowidn_mark,
+#ifdef CONFIG_SBG_SKB_MARK
+		.flowidn_zextmark = oldflp->flowidn_zextmark,
+#endif
 		.flowidn_iif = LOOPBACK_IFINDEX,
 		.flowidn_oif = oldflp->flowidn_oif,
 	};
@@ -975,13 +981,22 @@
 	__le16 gateway = 0;
 
 	if (decnet_debug_level & 16)
+#ifdef CONFIG_SBG_SKB_MARK
+		printk(KERN_DEBUG
+		       "dn_route_output_slow: dst=%04x src=%04x mark=%d zextmark=%u"
+		       " iif=%d oif=%d\n", le16_to_cpu(oldflp->daddr),
+		       le16_to_cpu(oldflp->saddr),
+		       oldflp->flowidn_mark, oldflp->flowidn_zextmark,LOOPBACK_IFINDEX,
+		       oldflp->flowidn_oif);
+
+#else
 		printk(KERN_DEBUG
 		       "dn_route_output_slow: dst=%04x src=%04x mark=%d"
 		       " iif=%d oif=%d\n", le16_to_cpu(oldflp->daddr),
 		       le16_to_cpu(oldflp->saddr),
 		       oldflp->flowidn_mark, LOOPBACK_IFINDEX,
 		       oldflp->flowidn_oif);
-
+#endif
 	/* If we have an output interface, verify its a DECnet device */
 	if (oldflp->flowidn_oif) {
 		dev_out = dev_get_by_index(&init_net, oldflp->flowidn_oif);
@@ -1193,7 +1208,9 @@
 	rt->fld.flowidn_oif  = oldflp->flowidn_oif;
 	rt->fld.flowidn_iif  = 0;
 	rt->fld.flowidn_mark = oldflp->flowidn_mark;
-
+#ifdef CONFIG_SBG_SKB_MARK
+	rt->fld.flowidn_zextmark = oldflp->flowidn_zextmark;
+#endif
 	rt->rt_saddr      = fld.saddr;
 	rt->rt_daddr      = fld.daddr;
 	rt->rt_gateway    = gateway ? gateway : fld.daddr;
@@ -1259,6 +1276,9 @@
 			if ((flp->daddr == rt->fld.daddr) &&
 			    (flp->saddr == rt->fld.saddr) &&
 			    (flp->flowidn_mark == rt->fld.flowidn_mark) &&
+#ifdef CONFIG_SBG_SKB_MARK
+				(flp->flowidn_zextmark == rt->fld.flowidn_zextmark) &&
+#endif
 			    dn_is_output_route(rt) &&
 			    (rt->fld.flowidn_oif == flp->flowidn_oif)) {
 				dst_use(&rt->dst, jiffies);
@@ -1322,6 +1342,9 @@
 		.saddr = cb->src,
 		.flowidn_scope = RT_SCOPE_UNIVERSE,
 		.flowidn_mark = skb->mark,
+#ifdef CONFIG_SBG_SKB_MARK
+		.flowidn_zextmark = ZLD_CB_DATA(skb)->zextmark,
+#endif
 		.flowidn_iif = skb->dev->ifindex,
 	};
 	struct dn_fib_res res = { .fi = NULL, .type = RTN_UNREACHABLE };
@@ -1467,7 +1490,9 @@
 	rt->fld.flowidn_oif  = 0;
 	rt->fld.flowidn_iif  = in_dev->ifindex;
 	rt->fld.flowidn_mark = fld.flowidn_mark;
-
+#ifdef CONFIG_SBG_SKB_MARK
+	rt->fld.flowidn_zextmark = fld.flowidn_zextmark;
+#endif
 	rt->n = neigh;
 	rt->dst.lastuse = jiffies;
 	rt->dst.output = dn_rt_bug_sk;
@@ -1536,6 +1561,9 @@
 		    (rt->fld.daddr == cb->dst) &&
 		    (rt->fld.flowidn_oif == 0) &&
 		    (rt->fld.flowidn_mark == skb->mark) &&
+#ifdef CONFIG_SBG_SKB_MARK
+			 (rt->fld.flowidn_zextmark == ZLD_CB_DATA(skb)->zextmark) &&
+#endif
 		    (rt->fld.flowidn_iif == cb->iif)) {
 			dst_use(&rt->dst, jiffies);
 			rcu_read_unlock();
@@ -1631,6 +1659,7 @@
 	[RTA_MULTIPATH]		= { .type = NLA_NESTED },
 	[RTA_TABLE]		= { .type = NLA_U32 },
 	[RTA_MARK]		= { .type = NLA_U32 },
+	[RTA_ZEXTMARK]		= { .type = NLA_U32 },
 };
 
 /*
Index: linux-4.1.51/net/ipv4/fib_frontend.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/fib_frontend.c	2019-04-18 11:28:19.291859396 +0800
+++ linux-4.1.51/net/ipv4/fib_frontend.c	2019-04-18 15:32:23.650710181 +0800
@@ -280,6 +280,10 @@
 		fl4.flowi4_tos = RT_TOS(ip_hdr(skb)->tos);
 		fl4.flowi4_scope = scope;
 		fl4.flowi4_mark = IN_DEV_SRC_VMARK(in_dev) ? skb->mark : 0;
+#ifdef CONFIG_SBG_SKB_MARK
+		fl4.flowi4_zextmark = IN_DEV_SRC_VMARK(in_dev) ? ZLD_CB_DATA(skb)->zextmark : 0;
+#endif
+
 		if (!fib_lookup(net, &fl4, &res))
 			return FIB_RES_PREFSRC(net, res);
 	} else {
@@ -317,6 +321,9 @@
 	no_addr = idev->ifa_list == NULL;
 
 	fl4.flowi4_mark = IN_DEV_SRC_VMARK(idev) ? skb->mark : 0;
+#ifdef CONFIG_SBG_SKB_MARK
+	fl4.flowi4_zextmark = IN_DEV_SRC_VMARK(idev) ? ZLD_CB_DATA(skb)->zextmark : 0;
+#endif
 
 	net = dev_net(dev);
 	if (fib_lookup(net, &fl4, &res))
@@ -1002,6 +1009,9 @@
 	struct fib_result       res;
 	struct flowi4           fl4 = {
 		.flowi4_mark = frn->fl_mark,
+#ifdef CONFIG_SBG_SKB_MARK
+		.flowi4_zextmark = frn->fl_zextmark,
+#endif
 		.daddr = frn->fl_addr,
 		.flowi4_tos = frn->fl_tos,
 		.flowi4_scope = frn->fl_scope,
Index: linux-4.1.51/net/ipv4/ipmr.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/ipmr.c	2019-04-18 11:28:19.291859396 +0800
+++ linux-4.1.51/net/ipv4/ipmr.c	2019-04-18 11:28:19.719859392 +0800
@@ -460,6 +460,9 @@
 		.flowi4_oif	= dev->ifindex,
 		.flowi4_iif	= skb->skb_iif ? : LOOPBACK_IFINDEX,
 		.flowi4_mark	= skb->mark,
+#ifdef CONFIG_SBG_SKB_MARK
+		.flowi4_zextmark = ZLD_CB_DATA(skb)->zextmark,
+#endif
 	};
 	int err;
 
@@ -1985,6 +1988,9 @@
 			       LOOPBACK_IFINDEX :
 			       skb->dev->ifindex),
 		.flowi4_mark = skb->mark,
+#ifdef CONFIG_SBG_SKB_MARK
+		.flowi4_zextmark = ZLD_CB_DATA(skb)->zextmark,
+#endif
 	};
 	struct mr_table *mrt;
 	int err;
Index: linux-4.1.51/net/ipv4/xfrm4_policy.c
===================================================================
--- linux-4.1.51.orig/net/ipv4/xfrm4_policy.c	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/net/ipv4/xfrm4_policy.c	2019-04-18 11:28:19.719859392 +0800
@@ -111,6 +111,9 @@
 
 	memset(fl4, 0, sizeof(struct flowi4));
 	fl4->flowi4_mark = skb->mark;
+#ifdef CONFIG_SBG_SKB_MARK
+	fl4->flowi4_zextmark = ZLD_CB_DATA(skb)->zextmark;
+#endif
 	fl4->flowi4_oif = reverse ? skb->skb_iif : oif;
 
 	if (!ip_is_fragment(iph)) {
Index: linux-4.1.51/net/xfrm/xfrm_policy.c
===================================================================
--- linux-4.1.51.orig/net/xfrm/xfrm_policy.c	2018-03-28 04:15:21.000000000 +0800
+++ linux-4.1.51/net/xfrm/xfrm_policy.c	2019-04-19 08:58:05.052104030 +0800
@@ -734,13 +734,25 @@
 {
 	u32 mark = policy->mark.v & policy->mark.m;
 
-	if (policy->mark.v == pol->mark.v && policy->mark.m == pol->mark.m)
+#ifdef CONFIG_SBG_SKB_MARK
+	u32 zextmark = policy->zextmark.v & policy->zextmark.m;
+
+	if (( policy->mark.v == pol->mark.v && policy->mark.m == pol->mark.m) &&
+	( policy->zextmark.v == pol->zextmark.v && policy->zextmark.m == pol->zextmark.m) )
 		return true;
 
 	if ((mark & pol->mark.m) == pol->mark.v &&
+		(zextmark & pol->zextmark.m) == pol->zextmark.v &&
 	    policy->priority == pol->priority)
 		return true;
+#else
+	if (policy->mark.v == pol->mark.v && policy->mark.m == pol->mark.m)
+		return true;
 
+	if ((mark & pol->mark.m) == pol->mark.v &&
+	    policy->priority == pol->priority)
+		return true;
+#endif
 	return false;
 }
 
@@ -825,6 +837,9 @@
 	hlist_for_each_entry(pol, chain, bydst) {
 		if (pol->type == type &&
 		    (mark & pol->mark.m) == pol->mark.v &&
+#if 0 // CONFIG_SBG_SKB_MARK
+		    (zextmark & pol->zextmark.m) == pol->zextmark.v &&
+#endif
 		    !selector_cmp(sel, &pol->selector) &&
 		    xfrm_sec_ctx_match(ctx, pol->security)) {
 			xfrm_pol_hold(pol);
@@ -865,6 +880,9 @@
 	ret = NULL;
 	hlist_for_each_entry(pol, chain, byidx) {
 		if (pol->type == type && pol->index == id &&
+#if 0 // CONFIG_SBG_SKB_MARK
+		    (zextmark & pol->zextmark.m) == pol->zextmark.v &&
+#endif
 		    (mark & pol->mark.m) == pol->mark.v) {
 			xfrm_pol_hold(pol);
 			if (delete) {
@@ -1073,6 +1091,9 @@
 	bool match;
 
 	if (pol->family != family ||
+#ifdef CONFIG_SBG_SKB_MARK
+		(fl->flowi_zextmark & pol->zextmark.m) != pol->zextmark.v ||
+#endif
 	    (fl->flowi_mark & pol->mark.m) != pol->mark.v ||
 	    pol->type != type)
 		return ret;
@@ -1347,6 +1368,9 @@
 		newp->lft = old->lft;
 		newp->curlft = old->curlft;
 		newp->mark = old->mark;
+#ifdef CONFIG_SBG_SKB_MARK
+		newp->zextmark = old->zextmark;
+#endif
 		newp->action = old->action;
 		newp->flags = old->flags;
 		newp->xfrm_nr = old->xfrm_nr;
